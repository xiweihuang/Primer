/**********
	
【队列】
给定一个无向连通图，假定所有边的权值都为1，显然，从源点到终点有多条最短路径，求不同的最短路径的数目。

**********/

#include <iostream>
#include <queue>
using namespace std;

const int N = 8;

void Calc(int G[N][N], int& stepCount, int& pathCount)
{
	int step[N] = {0};  // 每个结点最少可以几步到达
	int path[N] = {0};  // 到每个结点有几条最短路径
	path[0] = 1;

	// 应该用什么数据结构？
	// 这里就是一个遍历搜索的问题，那被搜索的结点满足什么条件？
	// 该结点是必须已经有路径可以到达的。
	// 假设现在搜索A结点，完了之后，再搜索完全不相通的M结点，那对M结点来说，是完全干不了任何工作的，因为与M连通的结点都没被遍历过
	// 所以就需要一个队列，所有满足被遍历搜索的结点加到队列中，然后一个一个地进行搜索，直到队列为空

	queue<int> q;
	q.push(0);  // 从第0个结点开始搜索
	while (!q.empty()) {
		int from = q.front();
		q.pop();
		
		for (int to = 1; to < N; ++to) {
			if (G[from][to] == 1) {  // 是连通的
				if (step[to] == 0 || step[to] > step[from] + 1) {
					step[to] = step[from] + 1;
					path[to] = path[from];
					q.push(to);
				} else if (step[to] == step[from] + 1) {
					path[to] += path[from];
				}
			}
		}
	}

	// return step[N-1];
	stepCount = step[N-1];
	pathCount = path[N-1];
}


void test1()
{
	int G[N][N] = {0};
	// G[0][1] = G[0][4] = 1;
	// G[1][0] = G[1][2] = G[1][5] = 1;
	// G[2][1] = G[2][3] = G[2][6] = 1;
	// G[3][2] = G[3][7] = 1;
	// G[4][0] = G[4][5] = 1;
	// G[5][1] = G[5][4] = G[5][6] = G[5][9] = 1;
	// G[6][2] = G[6][5] = G[6][7] = G[6][10] = 1;
	// G[7][3] = G[7][6] = 1;
	// G[8][9] = G[8][12] = 1;
	// G[9][5] = G[9][8] = G[9][10] = G[9][13] = 1;
	// G[10][6] = G[10][9] = G[10][11] = G[10][14] = 1;
	// G[11][10] = G[11][15] = 1;
	// G[12][8] = G[12][13] = 1;
	// G[13][9] = G[13][12] = G[13][14] = 1;
	// G[14][10] = G[14][13] = G[14][15] = 1;
	// G[15][11] = G[15][14] = 1;

	G[0][1] = G[0][3] = 1;
	G[1][0] = G[1][4] = G[1][2] = 1;
	G[2][1] = G[2][5] = 1;
	G[3][0] = G[3][4] = 1;
	G[4][3] = G[4][1] = G[4][6] = G[4][5] = 1;
	G[5][2] = G[5][4] = G[5][7] = 1;
	G[6][4] = G[6][7] = 1;
	G[7][5] = G[7][6] = 1;

	int step = 0, path = 0;
	Calc(G, step, path);
	cout << step << "," << path << endl;
}


int main()
{
	test1();
	return 0;
}