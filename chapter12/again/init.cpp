/********** 

【初始化的基本概念】

事实：初始化和赋值是两个完全不同的操作。初始化，是创建变量时赋予其一个初始值。赋值，是把对象的当前值擦除，用一个新值代替。

列表初始化：
	作为c++11新标准的一部分，用花括号{}来初始化变量得到了全面应用。出于某些原因，这种初始化的方式叫做列表初始化。
	现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用一组花括号括起来的初始值了。
	当用于内置类型的变量时，如果我们使用列表初始化且初始值存在丢失信息的风险时，编译器会报错。


默认初始化：
	如果定义变量时没有指定初值，则变量被默认初始化。此时变量被赋予“默认值”。
	什么决定了默认值？
		1.变量类型
		2.定义变量的位置
	
	如果是内置类型的变量未被显示初始化，它的值由定义的位置决定。
		·定义于任何函数体之外的变量被初始化为0
		·一种例外，定义在函数体内部的内置类型变量将不被初始化（函数形参也是函数体内的自动变量，未被初始化也会是未定义的）
		（未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式进行访问将引发错误）

	如果是类，由类自己决定初始化对象的方式。而且，是否允许不经过初始化就定义对象也由类自己决定。
	绝大多数类都支持无需显式初始化而定义对象，这样的类提供了一个合适的默认值。

	（定义于函数体内的内置类型的对象如果没有初始化，则其值是未定义的）
	（类的对象如果没有显式地初始化，则其值由类确定）

小结1：
	1.什么是列表初始化？ --> {}
	2.什么是默认初始化？ --> 定义变量时没有指定初值，则变量被默认初始化。
	3.什么决定默认值？ --> 类型 + 位置
		·内置类型，定义在任何函数体之外的变量被初始化为0
		·类类型，由类自己决定。默认初始化应该就可以理解为调用默认的无参构造函数

**********/


#include <iostream>
#include <string>
using namespace std;


// 列表初始化
void init1()
{
	// 定义一个int变量并初始化为0，有几种方法：
	int num1 = 0;
	int num2 = {0};
	int num3{0};
	int num4(0);
	cout << num1 << num2 << num3 << num4 << endl;

	long double ld = 3.1415926536;
	// int a{ld}, b = {ld};  // 错误：转换未执行，因为存在丢失信息的危险
	int c(ld), d = ld;    // 正确：转换执行，且确实丢失了部分值
}


int a1, a2, a3, a4;  // 内置类型，函数体外，初始化为0

// 默认初始化
void init2()
{
	int b1, b2, b3, b4;  // 内置类型，函数体内，未被初始化
	cout << a1 << a2 << a3 << a4 << endl;
	cout << b1 << b2 << b3 << b4 << endl;
}


class Test
{
public:
	void output()
	{
		cout << a << b << c << d << endl;
	}
private:
	int a, b, c, d;  // 函数体外，初始化为0
};

void init3()
{
	Test t;
	t.output();
}

void init4()
{
	// 这里应该这样理解，string并非内置类型，应该是一个类类型，和Test的本质一样
	// 如果没有显示地初始化，那么就会调用该类的默认构造函数进行初始化
	string empty;  // empty非显式地初始化为一个空串
	Test t;  // 被默认初始化的t对象
}

// 练习
string global_str;
int global_int;
void exercise1()
{
	int local_int;
	string local_str;
	cout << global_str << ", " << global_int << endl;  // 0
	cout << local_str << ", " << local_int << endl;  // local_int未定义
}

int main()
{
	// init1();
	// init2();
	// init3();
	exercise1();
	return 0;
}
